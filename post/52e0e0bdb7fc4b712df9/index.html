<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head"/><link rel="preload" href="/_next/static/u8C3YsGP2Bm4wp3q4PX_E/pages/post.js" as="script"/><link rel="preload" href="/_next/static/u8C3YsGP2Bm4wp3q4PX_E/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/u8C3YsGP2Bm4wp3q4PX_E/pages/_error.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-89179faa512dd01fbb62.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.155a6b7fd69c7de94d76.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.bfed8636ba586d188500.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-b5a5bd8992fb5ea55a24.js" as="script"/><link rel="stylesheet" href="/_next/static/css/commons.f1439f29.chunk.css"/><link rel="stylesheet" href="/_next/static/css/styles.c3ffabf0.chunk.css"/></head><body><div id="__next"><div class="" data-reactroot=""><nav class="navbar is-white" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a class="navbar-item" href="/"><img style="max-height:none" src="/static/img/logo.png" width="112" height="28"/></a><div class="navbar-burger burger " data-target="navMenuDocumentation"><span></span><span></span><span></span></div></div><div class="navbar-menu "><div class="navbar-end"><a href="/" class="navbar-item">文章</a><a href="/books" class="navbar-item">读书</a><a href="/post/a1770bd3adecb9b5806c/" class="navbar-item">导航</a><a href="/papers/" class="navbar-item">周刊</a><a href="/twitter-notes/" class="navbar-item">小记</a><a href="/post/ee0195143ab8688c92e5/" class="navbar-item">关于</a></div></div></div></nav><div class="container markdown-body"><div><h2 id="javascript-this-">Javascript 闭包、This、箭头函数</h2>
<p>闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。</p>
<h3 id="-">闭包</h3>
<p>闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。</p>
<ul>
<li>静态作用域</li>
<li>动态作用域</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">"xiaofu"</span>;
<span class="hljs-keyword">var</span> person = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(lastname)</span></span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">'yang'</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">personName</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> name + lastname;
    }
    <span class="hljs-keyword">return</span> personName;
}
<span class="hljs-keyword">var</span> pName = person();
pName(<span class="hljs-string">"xiaoming"</span>);</code></pre>
<p>js是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？</p>
<p>如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name(“xiaofu”);而不是”yang”。</p>
<p>而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。</p>
<h3 id="this">this</h3>
<p>this则与变量有点不同，即this采用的是类似于动态作用域的情况。js里面一切都是对象，所以函数也都是某个对象的方法，如果没有显示指定则是全局对象。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> person = {
    <span class="hljs-attr">fullname</span>: <span class="hljs-function"><span class="hljs-keyword">function</span></span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
    },
    <span class="hljs-attr">printAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
    }
}
person.fullname();        <span class="hljs-comment">//this指向person</span>
<span class="hljs-keyword">var</span> age = person.printAge;
age();                    <span class="hljs-comment">//this指向window(浏览器中)</span></code></pre>
<p>将person.printAge赋值给age之后，再执行age(),此时age没有显示指定调用对象则默认是window(浏览器环境)。所以this并不是声明所在的环境。</p>
<h3 id="-es6-">箭头函数（es6)</h3>
<p>es6中新增了箭头函数，箭头函数与通过function声明的函数不同，它的this是使用的声明时上下文中的this.并且不可通过apply, call等改变。</p>
</div></div><div class="footer"><div class="container"><span>Copyright © 2015-2018 Yangxiaofu</span></div></div></div></div><script>__NEXT_DATA__ = {"props":{"pageProps":{"note":{"createdAt":"2018-10-10 16:52:56","updatedAt":"2018-10-11T09:04:20.287Z","type":"MARKDOWN_NOTE","folder":"d3441b01ef2251aec113","title":"Javascript 闭包、This、箭头函数","content":"\u003ch2 id=\"javascript-this-\"\u003eJavascript 闭包、This、箭头函数\u003c/h2\u003e\n\u003cp\u003e闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。\u003c/p\u003e\n\u003ch3 id=\"-\"\u003e闭包\u003c/h3\u003e\n\u003cp\u003e闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e静态作用域\u003c/li\u003e\n\u003cli\u003e动态作用域\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"xiaofu\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e person = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(lastname)\u003c/span\u003e\u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e'yang'\u003c/span\u003e;\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003epersonName\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e{\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e name + lastname;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e personName;\n}\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e pName = person();\npName(\u003cspan class=\"hljs-string\"\u003e\"xiaoming\"\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ejs是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？\u003c/p\u003e\n\u003cp\u003e如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name(“xiaofu”);而不是”yang”。\u003c/p\u003e\n\u003cp\u003e而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。\u003c/p\u003e\n\u003ch3 id=\"this\"\u003ethis\u003c/h3\u003e\n\u003cp\u003ethis则与变量有点不同，即this采用的是类似于动态作用域的情况。js里面一切都是对象，所以函数也都是某个对象的方法，如果没有显示指定则是全局对象。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e person = {\n    \u003cspan class=\"hljs-attr\"\u003efullname\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e\u003c/span\u003e{\n        \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n    },\n    \u003cspan class=\"hljs-attr\"\u003eprintAge\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e)\u003c/span\u003e{\n        \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e);\n    }\n}\nperson.fullname();        \u003cspan class=\"hljs-comment\"\u003e//this指向person\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e age = person.printAge;\nage();                    \u003cspan class=\"hljs-comment\"\u003e//this指向window(浏览器中)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e将person.printAge赋值给age之后，再执行age(),此时age没有显示指定调用对象则默认是window(浏览器环境)。所以this并不是声明所在的环境。\u003c/p\u003e\n\u003ch3 id=\"-es6-\"\u003e箭头函数（es6)\u003c/h3\u003e\n\u003cp\u003ees6中新增了箭头函数，箭头函数与通过function声明的函数不同，它的this是使用的声明时上下文中的this.并且不可通过apply, call等改变。\u003c/p\u003e\n","tags":["hot"],"isStarred":false,"isTrashed":false,"key":"52e0e0bdb7fc4b712df9","folderName":"yangxiaofu-blog"}}},"page":"/post","pathname":"/post","query":{"id":"52e0e0bdb7fc4b712df9"},"buildId":"u8C3YsGP2Bm4wp3q4PX_E","nextExport":true};__NEXT_LOADED_PAGES__=[];__NEXT_REGISTER_PAGE=function(r,f){__NEXT_LOADED_PAGES__.push([r, f])}</script><script async="" id="__NEXT_PAGE__/post" src="/_next/static/u8C3YsGP2Bm4wp3q4PX_E/pages/post.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/static/u8C3YsGP2Bm4wp3q4PX_E/pages/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/_next/static/u8C3YsGP2Bm4wp3q4PX_E/pages/_error.js"></script><script src="/_next/static/runtime/webpack-89179faa512dd01fbb62.js" async=""></script><script src="/_next/static/chunks/commons.155a6b7fd69c7de94d76.js" async=""></script><script src="/_next/static/chunks/styles.bfed8636ba586d188500.js" async=""></script><script src="/_next/static/runtime/main-b5a5bd8992fb5ea55a24.js" async=""></script></body></html>